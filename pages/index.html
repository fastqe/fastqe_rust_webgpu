<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU GPU Info</title>
</head>
<body>
    <h2>WebGPU GPU Information</h2>
    <p id="gpu-info">Detecting your GPU...</p>
 
    <h1>CPU (WASM) Version</h1>
    <p id="wasm-result">Running WASM...</p>

    <h1>GPU (WebGPU) Version</h1>
    <p id="compute-input-sums">Input 1... </p>
    <p id="compute-input-counts">Input 2... </p>

    <p id="compute-result">Running compute shader... </p>
    <p id="compute-result-emoji">Convert means to... </p>

    <script  src="https://biowasm.com/cdn/v3/aioli.js"></script>

    <script>

function getFastqEmojiMapCustom() {
  const fastqEmojiMapCustom = {
    0: 'ğŸŒ‹',
    1: 'ğŸŒŒ',
    2: 'ğŸª',
    3: 'âœ¨',
    4: 'âš¡',
    5: 'ğŸŒ ',
    6: 'ğŸ’¥',
    7: 'ğŸ”¥',
    8: 'ğŸŒŸ',
    9: 'ğŸŒˆ',
    10: 'ğŸŒ',
    11: 'ğŸŒ›',
    14: 'ğŸŒœ',
    12: 'ğŸŒ“',
    13: 'ğŸŒ’',
    15: 'ğŸŒ‘',
    16: 'ğŸŒ•',
    17: 'ğŸŒ–',
    18: 'ğŸŒ—',
    19: 'ğŸŒ˜',
    20: 'ğŸª„',
    21: 'ğŸª',
    22: 'ğŸ›¸',
    23: 'ğŸª',
    24: 'ğŸŒ€',
    25: 'ğŸŒŠ',
    26: 'ğŸŒ«ï¸',
    27: 'ğŸŒ¬ï¸',
    29: 'â˜ï¸',
    31: 'â›ˆï¸',
    28: 'ğŸŒ¤ï¸',
    30: 'ğŸŒ¥ï¸',
    32: 'ğŸŒ¦ï¸',
    33: 'ğŸŒ§ï¸',
    34: 'ğŸŒ¨ï¸',
    35: 'ğŸŒ©ï¸',
    36: 'ğŸŒªï¸',
    37: 'ğŸŒ«ï¸',
    38: 'ğŸŒ€',
    39: 'ğŸŒ ',
    40: 'ğŸŒŒ',
    41: 'ğŸŒ‹'
  };
  return fastqEmojiMapCustom;
}

function getFastqEmojiMap() {
  const fastqEmojiMap = {
    0: 'ğŸš«',
    1: 'âŒ',
    2: 'ğŸ‘º',
    3: 'ğŸ’”',
    4: 'ğŸ™…',
    5: 'ğŸ‘¾',
    6: 'ğŸ‘¿',
    7: 'ğŸ’€',
    8: 'ğŸ‘»',
    9: 'ğŸ™ˆ',
    10: 'ğŸ™‰',
    11: 'ğŸ™Š',
    14: 'ğŸ˜¾',
    12: 'ğŸµ',
    13: 'ğŸ˜¿',
    15: 'ğŸ™€',
    16: 'ğŸ’£',
    17: 'ğŸ”¥',
    18: 'ğŸ˜¡',
    19: 'ğŸ’©',
    20: 'ğŸš¨',
    21: 'ğŸ˜€',
    22: 'ğŸ˜…',
    23: 'ğŸ˜',
    24: 'ğŸ˜Š',
    25: 'ğŸ˜™',
    26: 'ğŸ˜—',
    27: 'ğŸ˜š',
    29: 'ğŸ˜˜',
    31: 'ğŸ˜„',
    28: 'ğŸ˜ƒ',
    30: 'ğŸ˜†',
    32: 'ğŸ˜‹',
    33: 'â˜ºï¸',
    34: 'ğŸ˜›',
    35: 'ğŸ˜',
    36: 'ğŸ˜œ',
    37: 'ğŸ˜',
    38: 'ğŸ˜„',
    39: 'ğŸ˜',
    40: 'ğŸ˜',
    41: 'ğŸ˜‰'
  };
  return fastqEmojiMap;
}

function getFastqEmojiMapBinned() {
  const fastqEmojiMapBinned = {
    0: 'ğŸš«',
    1: 'ğŸš«',
    2: 'ğŸ’€',
    3: 'ğŸ’€',
    4: 'ğŸ’€',
    5: 'ğŸ’€',
    6: 'ğŸ’€',
    7: 'ğŸ’€',
    8: 'ğŸ’€',
    9: 'ğŸ’€',
    10: 'ğŸ’©',
    11: 'ğŸ’©',
    12: 'ğŸ’©',
    13: 'ğŸ’©',
    14: 'ğŸ’©',
    15: 'ğŸ’©',
    16: 'ğŸ’©',
    17: 'ğŸ’©',
    18: 'ğŸ’©',
    19: 'ğŸ’©',
    20: 'ğŸš¨',
    21: 'ğŸš¨',
    22: 'ğŸš¨',
    23: 'ğŸš¨',
    24: 'ğŸš¨',
    25: 'ğŸ˜„',
    26: 'ğŸ˜„',
    27: 'ğŸ˜„',
    28: 'ğŸ˜„',
    29: 'ğŸ˜„',
    30: 'ğŸ˜†',
    31: 'ğŸ˜†',
    32: 'ğŸ˜†',
    33: 'ğŸ˜†',
    34: 'ğŸ˜†',
    35: 'ğŸ˜',
    36: 'ğŸ˜',
    37: 'ğŸ˜',
    38: 'ğŸ˜',
    39: 'ğŸ˜',
    40: 'ğŸ˜',
    41: 'ğŸ˜'
  };
  return fastqEmojiMapBinned;
}

function getFastqNoEmojiMap() {
  const fastqNoEmojiMap = {
    0: 'â–',
    1: 'â–',
    2: 'â–‚',
    3: 'â–‚',
    4: 'â–‚',
    5: 'â–‚',
    6: 'â–‚',
    7: 'â–‚',
    8: 'â–‚',
    9: 'â–‚',
    10: 'â–ƒ',
    11: 'â–ƒ',
    12: 'â–ƒ',
    13: 'â–ƒ',
    14: 'â–ƒ',
    15: 'â–ƒ',
    16: 'â–ƒ',
    17: 'â–ƒ',
    18: 'â–ƒ',
    19: 'â–ƒ',
    20: 'â–„',
    21: 'â–„',
    22: 'â–„',
    23: 'â–„',
    24: 'â–„',
    25: 'â–…',
    26: 'â–…',
    27: 'â–…',
    28: 'â–…',
    29: 'â–…',
    30: 'â–†',
    31: 'â–†',
    32: 'â–†',
    33: 'â–†',
    34: 'â–†',
    35: 'â–‡',
    36: 'â–‡',
    37: 'â–‡',
    38: 'â–‡',
    39: 'â–‡',
    40: 'â–ˆ',
    41: 'â–ˆ'
  };
  return fastqNoEmojiMap;
}

// Usage example
const seqEmojiMap = getFastqEmojiMap();
console.log(seqEmojiMap[23]); // Output: :apple:

const fastqEmojiMap = getFastqEmojiMap();
console.log(fastqEmojiMap[1]); // Output: :bomb:


        async function getGPUInfo() {
            console.log('Starting getGPUInfo function');

            // Check if WebGPU is supported
            if (!navigator.gpu) {
                console.log('WebGPU is not supported on this browser.');
                document.getElementById('gpu-info').textContent = 'WebGPU is not supported on this browser.';
                return;
            }

            try {
                console.log('Requesting GPU adapter...');
                // Request an adapter
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    console.log('No suitable GPU adapter found.');
                    document.getElementById('gpu-info').textContent = 'No suitable GPU adapter found.';
                    return;
                } else {
			document.getElementById('gpu-info').textContent = adapter;
		}
		    

//                 console.log('GPU adapter found:', adapter);
//                 // Print the GPU details to the web page
//                 const gpuName = adapter.info.vendor;
//                 document.getElementById('gpu-info').textContent = `GPU Vendor: ${gpuName}`;
//                 console.log('GPU Name:', gpuName);

// // Check for specific Apple M-series GPUs
// if (gpuName.includes("Apple M1")) {
//     console.log('Detected an Apple M1 GPU');
//     document.getElementById('gpu-info').textContent += ' (Apple M1)';
// } else if (gpuName.includes("Apple M2")) {
//     console.log('Detected an Apple M2 GPU');
//     document.getElementById('gpu-info').textContent += ' (Apple M2)';
// } else if (gpuName.includes("Apple M3")) {
//     console.log('Detected an Apple M3 GPU');
//     document.getElementById('gpu-info').textContent += ' (Apple M3)';
// }


                // Assume the sums and counts arrays are sourced from another program and passed in here
                const { sumsArray, countsArray } = await getNumberArraysFromExternalSource();


                // Run a basic computation using a compute shader
                //await runComputeShader();
                if (sumsArray.length !== countsArray.length) {
                    console.error('Sums and counts arrays must be of the same length.');
                    document.getElementById('compute-result').textContent = 'Error: Sums and counts arrays must be of the same length.';
                    return;
                };
                document.getElementById('compute-input-sums').textContent += `Sums... ${sumsArray.join(' ')}`;
                document.getElementById('compute-input-counts').textContent += `Counts... ${countsArray.join(' ')}`;


                await runComputeShader(sumsArray, countsArray);


                // Load and run the WASM module
               
            } catch (error) {
                console.error('An error occurred while trying to access the GPU:', error);
                document.getElementById('gpu-info').textContent = error;
                
            }
        }


        async function getNumberArraysFromExternalSource() {
            // Placeholder function to simulate reading sums and counts arrays from another program
            // Assume the input is a two-line string where the first line is sums and the second is counts
            console.log('Fetching sums and counts arrays from external source...');
            //const input = `10.0, 20.0, 30.0
//2.0, 4.0, 5.0`;

const CLI = await new Aioli([{tool: "fastqe",
        program: "fastqe",         
        urlPrefix: "https://fastqe.github.io/fastqe_rust_webgpu/",
    }]);


await CLI.mount({
	name: "test.fq",
    data: "@HWI-D00360:5:H814YADXX:1:2209:15175:39729 1:N:0:CGATGT\nTTGGAGGATTTTGGAGAATCCCCTTAGGGGGAAATGTTTAAAAGTGCAAAGTGAATAGTAGAAGCCCCTCTCCTCGTCACTAGGGGTACATTTGCCGTTTTCTTATCAACAGCCTCTCAAGTACAAGCATCTGGGACAAGAACTAGAA\n+\n@CCFFFFFHHHHHJIIIJJJJJJJJJJJJJJGIJIIIIJJJJIJCHIIJJJ@GGJJJIGIJJHGGHHFFFDEEEEDDDDDDDDDDD;@CDEEEEDDDBDDDDCDDDDECCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDC\n@HWI-D00360:5:H814YADXX:1:2209:15401:39509 1:N:0:CGATGT\nAACTTCTTTTGCCCAGTCCTAATTTTTCTCCTCTTTTCCACGGGAATTGAGCCCAATAACACTTCATAATAACTATCTTAAATACTAAACTCATCTCAGCATTTTCTTCCTGGGGAATCTGACGTGATAGCCACAAATAGCATGTAGA\n+\nCCCFFFFFHHHHHJJJIIJJJJJJJJJJJJJJJJJJJJJJJJIJJJJIJJJIJJJJJJJJIJJJJIJIJJHHHHHHFFFFFFFEEEEEEDDDDDDCDDDDDCCDEEDDDDDD?BDDDDDDEDDDDDDDEDDDDDDDDDDDDDEDDEEC\n@HWI-D00360:5:H814YADXX:1:2209:15260:39576 1:N:0:CGATGT\nCGTGTTTTGTTGGCTTAGTTTTTGCTCTCATTGAGAGAAATAATATTGCTTTGCCATAGTAATTGAGTTTAACTACTGACACTTTCCATAGTCTAAAATTAATTGCTTTTAAGAAGAAATATTAGTTGAGGTTTCCAACGTTAGACCC\n+\n?@@DDDEFGFHFHIIGIJJJGHHIIJGIGGHEHEFBFHGGGIJIDDFGHIIJJJJIIEIFFEEGHEHFDFHJJJJJIHFEEHEDFEDEDEECCEDECCDDDCDDDDDDCDDCACACDACCDEDDCCDCCCCDDCCCCCC?AC??C@AA\n@HWI-D00360:5:H814YADXX:1:2209:15451:39625 1:N:0:CGATGT\nCGTTAGTTCATCAGCAATGGATCCAAACCAAGATGAAGTCTCTGATTTACCTGAAAAAGAAATCAGAAGGATAGTTATTAAGCTAATCAGGGAGAGACCAGAGAAAGTGAAAGCCCAATGCAAGGAAATCCAAAAACTGATATGAGAA\n+\nBCBFFFFFHHHHHJJJHJJJJJJJJJJJJJJJJJJJJJIIIJIJJJJJJJJJJJJJJIJJJJJJJJJJJJJJJHHHHHHHFFFFFFFEEEECDDDDDDDDDDDDDDDCDDEDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEDEDDD"
});

let output_help = await CLI.exec("fastqe test.fq");



            const input =  output_help;
            //document.getElementById("output_help"); 

            const [sumsLine, countsLine] = input.split('\n');
            console.log(sumsLine);
            console.log(countsLine);

            
            const sumsArray = new Float32Array(sumsLine.split(', ').map(Number));
            const countsArray = new Float32Array(countsLine.split(', ').map(Number));
            return { sumsArray, countsArray };
        }

       


        async function runComputeShader(sumsArray, countsArray) {
            console.log('Starting runComputeShader function');

            try {
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();

                // // Create a GPU buffer to store data
                // const bufferSize = 4; // 4 bytes (1 float)
                // const gpuBuffer = device.createBuffer({
                //     size: bufferSize,
                //     usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                // });

                 // Create GPU buffers for sums and counts
                 const bufferSize = sumsArray.byteLength;
                 const sumsBuffer = device.createBuffer({
                    size: bufferSize,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(sumsBuffer, 0, sumsArray.buffer, 0, bufferSize);

                const countsBuffer = device.createBuffer({
                    size: bufferSize,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(countsBuffer, 0, countsArray.buffer, 0, bufferSize);
                // Create a buffer for the results (means)
                const resultBuffer = device.createBuffer({
                    size: bufferSize,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                });


                // Create a staging buffer to read the results back to the CPU
                const stagingBuffer = device.createBuffer({
                    size: bufferSize,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
                });



// Create a shader module with a compute shader to calculate the mean for each value
const shaderModule = device.createShaderModule({
                    code: `
                         @group(0) @binding(0) var<storage, read_write> sums : array<f32>;
                        @group(0) @binding(1) var<storage, read_write> counts : array<f32>;
                        @group(0) @binding(2) var<storage, read_write> results : array<f32>;

                        @compute @workgroup_size(64)
                        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
                            let index = GlobalInvocationID.x;
                            
                            if (counts[index] != 0.0) {
                                results[index] = round(sums[index] / counts[index] - 33.0);
                            } else {
                                results[index] = 0.0; // Handle division by zero
                            }
                        }
                    `,
                });






               // Create a bind group layout and bind group
               const bindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        {
                            binding: 0,
                            visibility: GPUShaderStage.COMPUTE,
                            buffer: {
                                type: 'storage',
                            },
                        },
                        {
                            binding: 1,
                            visibility: GPUShaderStage.COMPUTE,
                            buffer: {
                                type: 'storage',
                            },
                        },
                        {
                            binding: 2,
                            visibility: GPUShaderStage.COMPUTE,
                            buffer: {
                                type: 'storage',
                            },
                        },
                    ],
                });

                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                         {
                            binding: 0,
                            resource: {
                                buffer: sumsBuffer,
                            },
                        },
                        {
                            binding: 1,
                            resource: {
                                buffer: countsBuffer,
                            },
                        },
                        {
                            binding: 2,
                            resource: {
                                buffer: resultBuffer,
                            },
                        },
                    ],
                });

                // Create a pipeline for the compute shader
                const computePipeline = device.createComputePipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                    compute: {
                        module: shaderModule,
                        entryPoint: 'main',
                    },
                });

                 // Encode commands to run the compute shader
                 const commandEncoder = device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(computePipeline);
                passEncoder.setBindGroup(0, bindGroup);
                //passEncoder.dispatchWorkgroups(sumsArray.length);
                passEncoder.dispatchWorkgroups(Math.ceil(sumsArray.length / 64));

                passEncoder.end();

                // // Copy the result to a buffer that can be read by the CPU
                // const readBuffer = device.createBuffer({
                //     size: bufferSize,
                //     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                // });
                // commandEncoder.copyBufferToBuffer(gpuBuffer, 0, readBuffer, 0, bufferSize);


                // Copy the result to the staging buffer
                commandEncoder.copyBufferToBuffer(resultBuffer, 0, stagingBuffer, 0, bufferSize);


                
                // Submit the commands
                const gpuCommands = commandEncoder.finish();
                device.queue.submit([gpuCommands]);

                // Read the result
                //await resultBuffer.mapAsync(GPUMapMode.READ);
                await stagingBuffer.mapAsync(GPUMapMode.READ);

                const arrayBuffer = stagingBuffer.getMappedRange();

                //const arrayBuffer = resultBuffer.getMappedRange();
                const means = new Float32Array(arrayBuffer);
                console.log('Means of arrays after subtracting 33:', means);
                document.getElementById('compute-result').textContent += `Means... ${means.join(' ')}`;
                const fastqEmojiMap = getFastqEmojiMapCustom();
                
                console.log('lookup test', fastqEmojiMap[3]);
                const integerArray = Array.from(means, value => Math.round(value));

                document.getElementById('compute-result-emoji').textContent +=  integerArray.map(value => fastqEmojiMap[value] || value).join('');

                resultBuffer.unmap();
            } catch (error) {
                console.error('An error occurred while running the compute shader:', error);
                document.getElementById('compute-result').textContent = 'An error occurred while running the compute shader.';
            }
        }

       

        console.log('Calling getGPUInfo function');
        //getGPUInfo();
    </script>


   <script type="module">

    
    const CLI = await new Aioli([{tool: "fastqe",
        program: "fastqe",         
        urlPrefix: "https://fastqe.github.io/fastqe_rust/",
    }]);


// Create mock fasta file
await CLI.mount({
	name: "test.fq",
    data: "@HWI-D00360:5:H814YADXX:1:2209:15175:39729 1:N:0:CGATGT\nTTGGAGGATTTTGGAGAATCCCCTTAGGGGGAAATGTTTAAAAGTGCAAAGTGAATAGTAGAAGCCCCTCTCCTCGTCACTAGGGGTACATTTGCCGTTTTCTTATCAACAGCCTCTCAAGTACAAGCATCTGGGACAAGAACTAGAA\n+\n@CCFFFFFHHHHHJIIIJJJJJJJJJJJJJJGIJIIIIJJJJIJCHIIJJJ@GGJJJIGIJJHGGHHFFFDEEEEDDDDDDDDDDD;@CDEEEEDDDBDDDDCDDDDECCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDC\n@HWI-D00360:5:H814YADXX:1:2209:15401:39509 1:N:0:CGATGT\nAACTTCTTTTGCCCAGTCCTAATTTTTCTCCTCTTTTCCACGGGAATTGAGCCCAATAACACTTCATAATAACTATCTTAAATACTAAACTCATCTCAGCATTTTCTTCCTGGGGAATCTGACGTGATAGCCACAAATAGCATGTAGA\n+\nCCCFFFFFHHHHHJJJIIJJJJJJJJJJJJJJJJJJJJJJJJIJJJJIJJJIJJJJJJJJIJJJJIJIJJHHHHHHFFFFFFFEEEEEEDDDDDDCDDDDDCCDEEDDDDDD?BDDDDDDEDDDDDDDEDDDDDDDDDDDDDEDDEEC\n@HWI-D00360:5:H814YADXX:1:2209:15260:39576 1:N:0:CGATGT\nCGTGTTTTGTTGGCTTAGTTTTTGCTCTCATTGAGAGAAATAATATTGCTTTGCCATAGTAATTGAGTTTAACTACTGACACTTTCCATAGTCTAAAATTAATTGCTTTTAAGAAGAAATATTAGTTGAGGTTTCCAACGTTAGACCC\n+\n?@@DDDEFGFHFHIIGIJJJGHHIIJGIGGHEHEFBFHGGGIJIDDFGHIIJJJJIIEIFFEEGHEHFDFHJJJJJIHFEEHEDFEDEDEECCEDECCDDDCDDDDDDCDDCACACDACCDEDDCCDCCCCDDCCCCCC?AC??C@AA\n@HWI-D00360:5:H814YADXX:1:2209:15451:39625 1:N:0:CGATGT\nCGTTAGTTCATCAGCAATGGATCCAAACCAAGATGAAGTCTCTGATTTACCTGAAAAAGAAATCAGAAGGATAGTTATTAAGCTAATCAGGGAGAGACCAGAGAAAGTGAAAGCCCAATGCAAGGAAATCCAAAAACTGATATGAGAA\n+\nBCBFFFFFHHHHHJJJHJJJJJJJJJJJJJJJJJJJJJIIIJIJJJJJJJJJJJJJJIJJJJJJJJJJJJJJJHHHHHHHFFFFFFFEEEECDDDDDDDDDDDDDDDCDDEDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEDEDDD"
});



     let output_help = await CLI.exec("fastqe test.fq");
     //document.getElementById("output_help").innerHTML = output_help.split("\t")[4];
     document.getElementById("wasm-result").innerHTML = output_help.split("\t")[4];

   
    // let fastqdata = await CLI.exec("fa test.fq");

//document.getElementById("fastq-file").innerHTML = "@HWI-D00360:5:H814YADXX:1:2209:15175:39729 1:N:0:CGATGT\nTTGGAGGATTTTGGAGAATCCCCTTAGGGGGAAATGTTTAAAAGTGCAAAGTGAATAGTAGAAGCCCCTCTCCTCGTCACTAGGGGTACATTTGCCGTTTTCTTATCAACAGCCTCTCAAGTACAAGCATCTGGGACAAGAACTAGAA\n+\n@CCFFFFFHHHHHJIIIJJJJJJJJJJJJJJGIJIIIIJJJJIJCHIIJJJ@GGJJJIGIJJHGGHHFFFDEEEEDDDDDDDDDDD;@CDEEEEDDDBDDDDCDDDDECCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDC\n@HWI-D00360:5:H814YADXX:1:2209:15401:39509 1:N:0:CGATGT\nAACTTCTTTTGCCCAGTCCTAATTTTTCTCCTCTTTTCCACGGGAATTGAGCCCAATAACACTTCATAATAACTATCTTAAATACTAAACTCATCTCAGCATTTTCTTCCTGGGGAATCTGACGTGATAGCCACAAATAGCATGTAGA\n+\nCCCFFFFFHHHHHJJJIIJJJJJJJJJJJJJJJJJJJJJJJJIJJJJIJJJIJJJJJJJJIJJJJIJIJJHHHHHHFFFFFFFEEEEEEDDDDDDCDDDDDCCDEEDDDDDD?BDDDDDDEDDDDDDDEDDDDDDDDDDDDDEDDEEC\n@HWI-D00360:5:H814YADXX:1:2209:15260:39576 1:N:0:CGATGT\nCGTGTTTTGTTGGCTTAGTTTTTGCTCTCATTGAGAGAAATAATATTGCTTTGCCATAGTAATTGAGTTTAACTACTGACACTTTCCATAGTCTAAAATTAATTGCTTTTAAGAAGAAATATTAGTTGAGGTTTCCAACGTTAGACCC\n+\n?@@DDDEFGFHFHIIGIJJJGHHIIJGIGGHEHEFBFHGGGIJIDDFGHIIJJJJIIEIFFEEGHEHFDFHJJJJJIHFEEHEDFEDEDEECCEDECCDDDCDDDDDDCDDCACACDACCDEDDCCDCCCCDDCCCCCC?AC??C@AA\n@HWI-D00360:5:H814YADXX:1:2209:15451:39625 1:N:0:CGATGT\nCGTTAGTTCATCAGCAATGGATCCAAACCAAGATGAAGTCTCTGATTTACCTGAAAAAGAAATCAGAAGGATAGTTATTAAGCTAATCAGGGAGAGACCAGAGAAAGTGAAAGCCCAATGCAAGGAAATCCAAAAACTGATATGAGAA\n+\nBCBFFFFFHHHHHJJJHJJJJJJJJJJJJJJJJJJJJJIIIJIJJJJJJJJJJJJJJIJJJJJJJJJJJJJJJHHHHHHHFFFFFFFEEEECDDDDDDDDDDDDDDDCDDEDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEDEDDD";



async function comparePerformance(gpuComputeFunction, wasmComputeFunction) {
  // Step 1: Benchmark the GPU Compute Shader

  const CLI = await new Aioli([{tool: "fastqe",
        program: "fastqe",         
        urlPrefix: "https://fastqe.github.io/fastqe_rust/",
    }]);
  const gpuStart = performance.now();
  await   getGPUInfo();
  const gpuEnd = performance.now();
  const gpuTime = gpuEnd - gpuStart;
  console.log(`GPU Compute Shader Time: ${gpuTime} ms`);

  // Step 2: Benchmark the CPU WASM Execution
  const wasmStart = performance.now();
  await CLI.exec("fastqe test.fq");
    const wasmEnd = performance.now();
  const wasmTime = wasmEnd - wasmStart;
  console.log(`CPU WASM Execution Time: ${wasmTime} ms`);

  // Step 3: Compare the results
  if (gpuTime < wasmTime) {
    console.log(`GPU is faster by ${wasmTime - gpuTime} ms`);
  } else {
    console.log(`CPU (WASM) is faster by ${gpuTime - wasmTime} ms`);
  }
}

// Example GPU compute function (replace with actual compute shader invocation)
async function gpuComputeFunction() {
  // Setup and execute GPU compute shader code here
  // For example: creating buffers, running dispatch, and reading results.
  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate GPU delay
}

// Example WASM compute function (replace with actual WASM computation)
function wasmComputeFunction() {
  // Compile and execute the WASM code here
  // Assuming that wasm computation is done synchronously
  for (let i = 0; i < 1e7; i++) {} // Simulate CPU work
}

// Compare the performance
comparePerformance(gpuComputeFunction, wasmComputeFunction);



     </script>


     <h4>Input sums and counts from  <code>fastqe </code>: </h4>
     <pre id="output_help">Loading... </pre>



     
</body>
</html>
